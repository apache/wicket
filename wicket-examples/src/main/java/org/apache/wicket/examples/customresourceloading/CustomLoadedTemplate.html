<?xml version="1.0" encoding="UTF-8"?>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta charset="utf-8">
<title>Home | Apache Wicket</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="shortcut icon" href="favicon.ico"
    type="image/vnd.microsoft.icon" />
<link
    href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"
    rel="stylesheet" />

<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
</head>

<body>
    <div class="header default">
        <div class="l-container">
            <div class="logo">
                <a href="/"><img src="/img/logo-apachewicket-white.svg"
                    alt="Apache Wicket"></a>
            </div>
        </div>
    </div>
    <main>
        <div class="l-container">
          <p>
            This page was loaded by a component specific override. You can use that - with care - if you have
            to implement custom loading strategies that are very local to the component. For instance, a custom
            component that loads it's template from a database and for which you don't want the application
            to have to know about it's differing loading resource.
          </p>
          <p>
            This example loads the custom template just once, though it may reload when resource polling is
            turned on and the template changes. If you want a load the template every time a page (or panel)
            is requested, you can additionally let your container implement IMarkupCacheKeyProvider, and then
            return null in the implementation of getCacheKey; Wicket will not cache templates without a
            cache key. This functionality can be used to e.g. when you want to load templates from a database,
            and you know that the actual templates can be different from request to request.
          </p>
    </main>
</body>
</html>